<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Stride Dashboard</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
</head>

<body>
  <section class="section">
    <div class="container">
      <h1 class="title">Monthly Running Summary</h1>

      <div class="columns">
        <div class="column is-two-thirds">
          <div class="box">
            <h2 class="subtitle">Monthly Pace</h2>
            <canvas id="paceChart"></canvas>
          </div>
          <div class="box">
            <h2 class="subtitle">Combined Overview</h2>
            <p class="is-size-7 has-text-grey">Minutes per zone (stacked), with distance and activity count overlaid.
            </p>
            <canvas id="combinedChart"></canvas>
          </div>
        </div>
        <div class="column">
          <div class="box">
            <h2 class="subtitle">Raw Data</h2>
            <pre id="raw"></pre>
          </div>
        </div>
      </div>
    </div>
  </section>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Injected by FastAPI (Jinja)
    const START = "{{ start }}";
    const END = "{{ end }}";

    function paceToSeconds(paceStr) {
      const [minStr, secStr] = paceStr.split(":");
      const minutes = Number(minStr);
      const seconds = Number(secStr);

      if (Number.isNaN(minutes) || Number.isNaN(seconds)) {
        throw new Error(`Invalid pace value: ${paceStr}`);
      }

      return minutes * 60 + seconds;
    }

    function secondsToPace(totalSeconds) {
      const mins = Math.floor(totalSeconds / 60);
      const secs = Math.round(totalSeconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")} min/km`;
    }

    function formatMinutes(mins) {
      if (!Number.isFinite(mins)) return "";
      const totalMinutes = Math.round(mins);
      const hours = Math.floor(totalMinutes / 60);
      const remainingMins = totalMinutes % 60;
      if (hours === 0) return `${remainingMins} min`;
      return `${hours}h ${remainingMins.toString().padStart(2, "0")}m`;
    }

    async function loadMonthly() {
      const url = `/api/pace/monthly?start=${encodeURIComponent(START)}&end=${encodeURIComponent(END)}`;
      const resp = await fetch(url);

      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`API error ${resp.status}: ${txt}`);
      }

      const payload = await resp.json();
      // depending on your API shape: { series: [...] } or [...]
      const series = payload.series ?? payload;

      document.getElementById("raw").textContent = JSON.stringify(payload, null, 2);

      if (!Array.isArray(series) || series.length === 0) {
        throw new Error("No data returned from API");
      }

      return series;
    }

    function renderPaceChart(series) {
      const labels = series.map(r => r.period_start);
      const paces = series.map(r => paceToSeconds(r.mn_per_km));

      const canvas = document.getElementById("paceChart");
      if (!canvas) throw new Error("Missing canvas#paceChart");

      const ctx = canvas.getContext("2d");

      new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [{
            label: "Pace (min/km)",
            data: paces,
            borderColor: "#485fc7",
            backgroundColor: "#485fc7",
            fill: false,
            tension: 0.25,
            pointRadius: 4,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          interaction: {
            mode: "index",
            intersect: false
          },
          scales: {
            y: {
              beginAtZero: false,
              reverse: true,
              ticks: {
                callback: (value) => secondsToPace(value)
              },
              title: {
                display: true,
                text: "Pace (min/km)"
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: (context) => {
                  const pace = secondsToPace(context.parsed.y);
                  return `${context.dataset.label}: ${pace}`;
                }
              }
            },
            legend: {
              display: true
            }
          }
        }
      });
    }

    function renderCombinedChart(series) {
      const labels = series.map(r => r.period_start);
      const totalMins = series.map(r => (paceToSeconds(r.mn_per_km) * r.distance_km) / 60);
      const distances = series.map(r => r.distance_km);
      const counts = series.map(r => r.count_activities ?? 0);

      const zones = ["z1_pct", "z2_pct", "z3_pct", "z4_pct", "z5_pct"];
      const colors = [
        "rgba(46, 204, 113, 0.6)",
        "rgba(52, 152, 219, 0.6)",
        "rgba(155, 89, 182, 0.6)",
        "rgba(241, 196, 15, 0.6)",
        "rgba(231, 76, 60, 0.6)"
      ];

      const zoneDatasets = zones.map((zKey, idx) => ({
        label: `Zone ${idx + 1}`,
        data: series.map((row, rowIdx) => totalMins[rowIdx] * (row[zKey] ?? 0)),
        backgroundColor: colors[idx],
        stack: "zones",
        borderWidth: 1,
        yAxisID: "yMinutes",
        type: "bar",
      }));

      const distanceDataset = {
        label: "Distance (km)",
        data: distances,
        borderColor: "#485fc7",
        backgroundColor: "rgba(72, 95, 199, 0.15)",
        type: "line",
        yAxisID: "yDistance",
        tension: 0.25,
        pointRadius: 3,
        fill: false,
      };

      const canvas = document.getElementById("combinedChart");
      if (!canvas) throw new Error("Missing canvas#combinedChart");

      const ctx = canvas.getContext("2d");

      new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [...zoneDatasets, distanceDataset],
        },
        options: {
          responsive: true,
          interaction: { mode: "index", intersect: false },
          scales: {
            x: { stacked: true },
            yMinutes: {
              stacked: true,
              beginAtZero: true,
              title: { display: true, text: "Minutes" },
              ticks: {
                callback: (value) => `${Math.round(value)} min`
              }
            },
            yDistance: {
              position: "right",
              beginAtZero: true,
              grid: { drawOnChartArea: false },
              title: { display: true, text: "Distance (km)" }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: (context) => {
                  const ds = context.dataset;
                  if (ds.stack === "zones") {
                    return `${ds.label}: ${formatMinutes(context.parsed.y)}`;
                  }
                  if (ds.label === "Distance (km)") {
                    return `${ds.label}: ${context.parsed.y.toFixed(1)} km`;
                  }
                  return `${ds.label}: ${context.parsed.y}`;
                },
                footer: (items) => {
                  // Sum only zone stacks for total minutes
                  const totalMinutes = items
                    .filter(item => item.dataset.stack === "zones")
                    .reduce((sum, item) => sum + item.parsed.y, 0);
                  const activityCount = counts[items[0].dataIndex] ?? 0;
                  const footerLines = [];
                  if (totalMinutes > 0) {
                    footerLines.push(`Total time: ${formatMinutes(totalMinutes)}`);
                  }
                  footerLines.push(`Activities: ${activityCount}`);
                  return footerLines.join("\n");
                }
              }
            },
            legend: { display: true }
          }
        }
      });
    }

    window.addEventListener("DOMContentLoaded", () => {
      loadMonthly()
        .then(series => {
          renderPaceChart(series);
          renderCombinedChart(series);
        })
        .catch(err => {
          console.error(err);
          document.getElementById("raw").textContent = `ERROR: ${err.message}\n\nCheck DevTools Console for details.`;
        });
    });
  </script>
</body>

</html>
